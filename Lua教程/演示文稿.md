---
marp: true
theme: default
class: invert
footer: MiniWorld Lua Script Tutorial by OWALabuy
style: |
  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
---

<!-- Add this anywhere in your Markdown file -->
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>

# 迷你世界Lua脚本入门教程

by 异端/世方府/欧阳闻奕

Github: @OWALabuy

UIN: 528278703

---

# 作者简介

**欧阳闻奕**(@OWALabuy), 猫, 二年级学生

迷你世界玩家, Minecraft玩家, 迷你号528278703

异端组织成员, 世方府工作室团伙头目, 异端**轨心夕**(**杀手没有恨**)的小弟

**最没有实力**的音乐玩家, 早期在西瓜视频做生存主播, 后期做音乐地图

---

# 目录

<div class="columns">
<div>

1. 认识Lua语言
2. 环境配置及文本编辑器
3. 变量及数据类型
4. 数值运算
5. 流程控制及布尔值运算
6. 循环

</div>
<div>

7. 字符串操作
8. 表
9. 函数
10. 游戏数据抽象
11. 事件监听器

</div>
</div>

---

<!-- _header: 1. 认识Lua语言-->
# 第一章

认识Lua语言

---

<!-- _header: 1. 认识Lua语言-目录-->

> 1. Lua简介
>       1. 迷你世界脚本的优点
>       2. 运行环境说明
> 2. 消除恐惧

---

<!-- _header: 1.1 Lua简介 -->

# Lua简介

**Lua**（发音： /ˈluːə/，葡萄牙语“月亮”）是一个简洁、轻量、可扩展的脚本语言。Lua有着相对简单的C语言API而很容易嵌入应用中。很多应用程序使用Lua作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。(*引自[维基百科](https://zh.wikipedia.org/wiki/Lua)*)

Lua语言是编程语言之一 编程语言是一种与计算机沟通的媒介 通过编程语言 我们可以命令机器按照我们的意图去工作 从而提高自己的工作效率

迷你世界内置了Lua脚本供玩家制作地图逻辑 提供了一系列API 可以实现各种功能 如破坏方块 放置方块 传送玩家等

迷你世界的Lua脚本可以实现强大的功能 有效帮助玩家进行地图创作

---

<!-- _header: 1.1.1 迷你世界脚本的优点 -->

## 迷你世界脚本的优点

相较于触发器 Lua脚本有以下优点:

1. **便于编写**: 脚本只需要一个文本编辑器即可编写 而触发器需要用鼠标点击和拖曳
2. **高效简洁**: 在Lua脚本中 创建变量和赋值只需要一行简单的代码 而在触发器中 需要大量的操作 这种差异尤其体现在大型脚本和复杂的逻辑中
3. **易于复制**: 使用脚本编写的逻辑可以复制到自己的其他地图中使用 或很方便地分享给其他玩家 而触发器不具备跨地图迁移功能
4. **适用于大型项目**: 使用脚本可以写一些大型的工具 *如作者的音乐方块生成器* 可以简化地图创作中的一些繁琐操作 而使用触发器不可以 想象一下 用4000多行代码实现的东西 如果用触发器来做 那得肝到爆

所以 学习脚本绝对是对玩家有利的一件事 可以方便地管理自己的地图逻辑

---

<!-- _header: 1.1.2 运行环境说明 -->

## 运行环境说明

迷你世界有端游和手游 它们都可以运行Lua脚本 但是玩家的编辑体验是不一样的

---

<!-- _header: 1.1.2.1 端游 -->

### 端游

迷你世界桌面版原生支持Windows系统 但是在GNU/Linux和MacOS中也可以通过Wine等兼容层运行

迷你世界端游提供了一个基于HTML的脚本编辑器 支持API参考 代码补全 语法高亮 多光标等功能 但是它有一定的缺点

1. 编辑的代码有一定概率丢失 这个问题 作者遇到过很多次
2. 不能使用自定义插件 如Vim插件 只能用鼠标操作 极其不方便

---

<!-- _header: 1.1.2.2 手游 -->

### 手游

迷你世界手游原生支持Android和IOS系统

手游版本不提供脚本编辑器相关功能 只有一个最基础的界面和一个API提示界面

作者不推荐使用迷你世界原生环境进行代码编写 后续会介绍更多便于使用的代码编辑器

---
<!-- _header: 1.2 消除恐惧-->

# 消除恐惧

在一些人心中 写代码是一种很难的事情 提到代码 就心生恐惧 觉得自己可能学不会 还没有入门就先泄气了

还有一种**错误且广泛**的观点: 写代码一定要英语好 其实根本不是这样的 没有学过英语的人 都可以学会写代码

对于Lua语言 需要记的词只有22个 如下 只要记住这些关键词的用法即可

```lua
and       break   do       else     elseif    end     false    for

function  if      in       local    nil       not     or       repeat

return    then    true     until    while     goto
```

---

<!-- _header: 1.2 消除恐惧-->

在本教程中 作者会尽量使用通俗的语言 详细的演示 生动的比喻来尽量使每一个观众理解那些概念

作者的目标是: 使小学阶段的玩家都能掌握脚本这一工具 所以不会讲特别难特别深入的内容 保证各位可以理解

所以请各位放心 在学完这些内容后 应该可以使用脚本来搭建你的地图逻辑了

<br/>

**我们遇到什么困难 都不要怕 微笑着面对它 消除恐惧的最好办法就是面对恐惧!!!**

**加油! 奥利给!!!!!!!!**

---

<!-- _header: 2. 环境配置及文本编辑器-->

# 第二章

环境配置与文本编辑器

---

<!-- _header: 2. 环境配置及文本编辑器-目录-->

> 1. 迷你世界环境
> 2. 在系统中配置Lua环境
>       1. Linux上的配置
>       2. 使用方法和交互模式
> 3. Visual Studio Code
>       1. vsc安装
>       2. vsc插件
> 4. 手机端可用的软件
>       1. AndroLua+
>       2. dcoder
>       3. vsc网页版

---

<!-- _header: 2.1 迷你世界环境 -->

# 迷你世界环境

迷你世界编辑模式的地图可以使用Lua脚本 步骤如下:

1. 以编辑模式打开一个高级创造模式的地图或老版本的开发者模式的地图
2. 点击"开发者工具"或按下J键
3. 点击"脚本" 高级创造模式下也可以直接按下L键
4. 选中或创建一个脚本组 在其中点击"新建脚本" 这会打开一个界面 可以在其中编写脚本
5. 退出会自动保存你的脚本 并且检查是否有错误 如果有语法错误会弹出一个弹窗
6. 退出脚本编辑界面之后 将右上角的测试调为开 这样在运行的时候可以看到控制台
7. 点击试玩 脚本就会运行

---

<!-- _header: 2.2 在系统中配置Lua环境-->

# 在系统中配置Lua环境

虽然这个教程主要是教大家在迷你世界中使用Lua脚本 但是在游戏中是有很多局限性的 迷你世界在2023年年初禁用了文件io和debug库等功能

Lua不仅可以在游戏中实现很多功能 也可以在各种工作中提高你的效率 作者在这一节中简要讲一下Lua在系统中的配置

---

<!-- _header: 2.2.1 在Linux上的配置-->

## 在Linux上的配置

如果你使用的是Debian系列的发行版 如Ubuntu LinuxMint等 可以使用APT安装Lua环境

```bash
sudo apt install lua5.3
```

安装其他版本的Lua也可以 根据自己的需求安装即可

如果你使用的是其他的Linux发行版 可以采用自己的包管理器进行安装 也可以到Lua官网下载源代码进行编译

---

<!-- _header: 2.2.2 使用方法及交互模式-->

## 使用方法及交互模式

Lua文件的后缀名为`.lua` 创建一个文件 写入代码 保存退出

使用命令`lua yourfile.lua` 即可在终端运行这个脚本

Lua提供交互模式 可以在终端输入`lua`进入交互模式 ctrl+c退出

---

<!-- _header: 2.3 Visual Studio Code-->

# Visual Studio Code

Visual Studio Code是一个由微软公司开发的文本编辑器 开源跨平台 具有很强的可扩展性 支持多种编程语言 非常适合用来写代码和文档

迷你世界也提供了VSC的插件

本节对VSC的安装和配置做一个详细说明

---

<!-- _header: 2.3.1 vsc安装-->

## vsc安装

在[vsc官网](https://code.visualstudio.com/)下载适合自己系统的软件包 并进行安装(32位的windows系统已经停止支持 可用网页版)

在Linux发行版中 可以在包管理器中安装vsc 如debian系的APT

```bash
sudo apt install code
```

安装完毕后 在终端输入`code` 加上文件名或目录名 可以在vsc中打开这个文件或目录

例如 在当前工作路径下有一个名为`hello.lua`的文件 在终端键入

```bash
code hello.lua
```

即可打开此文件

---

<!-- _header: 2.3.2 vsc插件-->

## vsc插件

安装好了VSC之后 我们需要安装一些必要的插件 以下是几款推荐安装的插件

1. Vim插件
2. Lua插件
3. 迷你世界插件

---

<!-- _header: 2.3.2 vsc插件-->

### vsc应用商店插件

在vsc左侧的边栏中 点击扩展 在应用商店中搜索Lua 安装Lua相关的插件

安装vim插件 以便脱离鼠标编辑文本

### 迷你世界插件

迷你世界官方制作了一款vsc插件 支持一些API的提示 但是这款插件没有在vsc的应用商店中上线 我们需要去开发者学院下载

点击这个url 查看下载和安装的教程 [dev.mini1.cn](https://dev-wiki.mini1.cn/cyclopdeia?wikiMenuId=3&wikiId=2324)

---

<!-- _header: 2.4 手机端可用的软件-->

# 手机端可用的软件

有的小伙伴没有电脑 在手机上也有一些可以编辑代码的软件 本喵在这里推荐几款

大家可以在这些代码编辑软件中写好自己的代码 再粘贴到迷你世界中去

---

<!-- _header: 2.4 手机端可用的软件-->

### AndroLua+

本喵没有用过 不过迷你圈子里有很多手机玩家在用

### dcoder

支持语法高亮 代码补全等 可以云端存储和运行你的代码 每个文件的上限大概是2000行

有webapp和客户端app 如果你安装了客户端app 它会附带一个dcoder输入法 写代码非常方便 但是它不支持中文 如果要在注释中输入中文就需要切换到支持中文的输入法

### vsc网页版

基于web的vsc 支持语法高亮 代码补全等 还可以安装插件 网址:[vsc web](https://vscode.dev)

---

<!-- _header: 3. 变量及数据类型与代码基础 -->

# 第三章

变量及数据类型与代码基础

---

<!-- _header: 3. 变量及数据类型与代码基础-目录 -->

> 1. 变量及其命名规范
> 2. 数据类型
>       1. 数值 number
>       2. 字符串 string
>       3. 布尔值 boolean
>       4. 空值 nil
>       5. 表 table 函数 function
>       6. 获得一个变量的数据类型
> 3. 变量作用域简介
> 4. 注释与代码规范

---

<!-- _header: 3.1 变量及其命名规范 -->

# 变量及其命名规范

在编程语言中 变量就像一个盒子 里面装着对应的值

我们可以简单地定义一个变量

```lua
local myName = "欧阳闻奕"
print(myName)
```

在这段代码中 我们定义了一个名为`myName`的**变量** 并用`=`符号将**字符串**"欧阳闻奕"**赋值**给了它

用比较通俗的方式来表达: 我们制作了一个名为`myName`的**盒子** 将"欧阳闻奕"这个东西**装**了进去 当我们提到那个盒子的名字的时候 实际上指的是里面那个东西

执行这段代码 将会在终端输出 欧阳闻奕

---

<!-- _header: 3.1 变量及其命名规范 -->

## 变量的名字与命名规范

在上一个示例中 我们定义的变量的名字是`myName` 变量的名字和函数的名字被称为**标识符** 其实变量的名字是可以随便起的 只需要遵守以下的规范:

1. 由字母 和/或 数字 和/或 下划线`_`构成
2. 不可以以数字开头
3. 不可能使用关键字(保留字)

所以 `a` `myName` `my_name` `_my_name` `name2` `name_3`这样的名字都是合法的

而 `2ray` `$meao` `*^$#&^ufaiudf`这样的名字是不合法的

*注: 这里的"合法"指"符合语法规范"*

---

<!-- _header: 3.1 变量及其命名规范 -->

## 变量赋值的方法

Lua支持一次性对多个变量赋值 例如

```Lua
a, b, c = 3, 2, 1
```

该操作会分别将3, 2, 1赋值给变量`a`, `b`, `c`

如果变量的个数大于值的个数 多余的变量会被赋空值`nil`(*后面会在讲数据类型时提到*)

如果值的个数大于变量的个数 多会的值会被忽略

---

<!-- _header: 3.1 变量及其命名规范 -->

如果对一个变量多次赋值 后面的值会将前面的值覆盖掉 示例:

```lua
a = 3
print(a)
a = 4
print(a)
```

运行这段代码 可以看到有两个输出 一个是3 一个是4

---

<!-- _header: 3.1 变量及其命名规范 -->

## 命名惯例

在一个大型项目中 变量名可以达到几百个甚至几千个 如果全用`a` `b` `c`这样的标识符作为它们的名字 后续的编写和维护会变得极其困难 所以 使用清晰易懂的标识符是很有必要的

标识符的命名风格大致分为两种 分别是**下划线命名法** 和 **驼峰命名法**

---

<!-- _header: 3.1 变量及其命名规范 -->

### 下划线命名法

采用下划线连接各单词 例如`my_name` `total_number` `Linux_Is_Not_Unix`

### 驼峰命名法

将除了第一个单词之外的每个单词的第一个字符大写 在某些情况下 第一个单词的开头字符也可以大写

例如 `myName` `MiniWorld` `LinuxIsNotUnix`

---

<!-- _header: 3.2 数据类型  -->

# 数据类型

Lua语言中 总共有8种数据类型 分别是 `number` `string` `boolean` `nil` `table` `function` `userdata` `thread`

在这个教程中 我们会提到前六个数据类型 而在本节 我们只详细讲解前四个

在Lua中 你不需要对变量的数据类型进行显示的指定

变量的数据类型会根据其中的值来确定 你也可以为一个变量先后赋值不同数据类型的数据 以改变它的值

不像C/C++那样对数据类型要求严格的编程语言

---

<!-- _header: 3.2.1 number  -->

## number 数值

在Lua中 `number`类型包括整数和双精度浮点数 也就是小数

如 1314 114.514 -1024等

你可以直接将这些数值赋值给变量

```lua
a = 1314
b = 114.514
c = -1024
```

---

<!-- _header: 3.2.2 string  -->

## string 字符串

字符串是用单引号`'` 双引号`"` 双中括号`[[]]`括起来的一串文字

单行字符串使用单引号或双引号定义 多行字符串使用双中括号定义

```lua
str1 = '我是一个用单引号定义的字符串'
str2 = "我是用双引号定义的 我和单引号定义的没有什么区别 你想用哪个都行 但我是最常见的"
str3 = [[我是用中括号定义的字符串
我可以有
很多行]]
str4 = [==[如果你觉得双中括号不好看或不方便
可以在中括号中间加上数量相等的=号
像我这样]==]
```

---

<!-- _header: 3.2.3 boolean  -->

## boolean 布尔值

布尔值是用来定义真或假的值 它只有两个值 `true`和`false`

在Lua的判断中

空值`nil`和`false`会被判断为假

`true`和其他数据类型会被判断为真

---

<!-- _header: 3.2.4 nil  -->

## nil 空值

空值就代表一个不存在的值 当你尝试去检索一个没有定义过的变量 它会显示为`nil`

当你不想要一个变量了 可以通过将`nil`赋值给它 来删除它

```lua
--两个减号后面的字是注释 不会被看成代码运行 这会在注释那一节中详细讲
--我们没有定义过变量a
print(a) --这会输出nil

--给变量a赋值一个字符串
a = "我是a"
print(a) --这会输出 我是a

--删除a
a = nil
print(a) --这会输出nil
```

---

<!-- _header: 3.2.5 `table` and `function`  -->

## `table` and `function`

这是Lua中比较复杂的数据类型 表和函数

在这一章中暂时不详细讲 后续会有专门的章节介绍这现个数据类型的用法

---

<!-- _header: 3.2.6 获得一个变量的数据类型  -->

## 获得一个变量的数据类型

我们可以使用`type`来获取一个变量或一个值的数据类型 这会返回一个字符串

```lua
local a = '我是一个字符串'
local type_of_a = type(a)
print(type_of_a) --这将输出 string

--对一个没有定义过的变量求类型 会返回"nil"
print(type(awa)) --awa是没有定义过的变量

--同样 也可以对一个值检测数据类型
print(type(114514)) --输出 number
```

---

<!-- _header: 3.3 变量作用域简介 -->

# 变量作用域简介

在定义变量时 我们可以确定一个变量是**局部变量**还是**全局变量**

这可以用关键字`local`实现

```lua
local a = "我是一个局部变量"

b = "我前面没有local 我是全局变量"
```

我们现在还没有讲到复杂的代码结构 各位只需要记住定义即可 在流程控制和循环的章节的应用中 会对变量作用域有比较详细的演示和说明

---

<!-- _header: 3.4 注释与代码规范  -->

# 注释与代码规范

写代码需要遵守一定的代码规范 注释清晰 排版美观的代码不仅可以提高自己的编码效率 减少因为"看不懂自己代码"导致的麻烦 还可以使阅读你代码的人心情愉悦

---

<!-- _header: 3.4.1 注释  -->

# 注释

在代码中插入的用于解释说明的文本称为注释 这些文字会在运行时被忽略掉 不会被视作代码

写代码时使用注释是一个良好的编程习惯 可以解释一些代码的用途 利于后期修改和新增功能

在Lua中 注释分为单行注释和多行注释

---

<!-- _header: 3.4.1.1 单行注释  -->

## 单行注释

在一行中 两个-号后面的文本会被视为注释

```lua
--这是一行注释 在这里写的内容都不会被执行

--注释可以用来解释代码的意图
local a = "awa" --定义了一个变量 存入awa

--注释可以用于使代码不被执行 称为把代码"注释掉"
--print(a)
--把这个print语句注释掉就不会输出东西了
```

---

<!-- _header: 3.4.1.2 多行注释  -->

## 多行注释

多行注释又称块注释 可以是一行或多行 可以采用`--[[ --]]`来框住注释文本

```lua
--[[这里是一个块注释的开头
这些文字都会被注释掉的
这个地方是块注释的结尾
--]]
```
块注释与普通的注释有一个区别 如果你想 它可以插入到代码中而不会占用整行 但是本喵不推荐这样的做法 因为这样会让代码显得很杂乱

```lua
local --[[local是定义变量作用域的关键字 --]] a = 3

--这样写没有问题 但是看起来很乱 大家尽量不要这样写
```

---

<!-- _header: 3.4.1.2 多行注释  -->

在注释很长的代码块时 有可能想要注释的代码已经包含了`--[[--]]`包围的块注释了 这个时候如果还想再在外面套一层块注释 就会出现问题

```lua
--我想从这里开始块注释 但是如果写了--[[ 会与下面的结束标识配对 而不能正确与最后的结束标识配对
--[[对玩家显示聊天框系统消息(重构) 参数是字符串和玩家迷你号
规范化参数避免缺参--]]
local function msg(content, UIN)
    if(content and UIN == nil) --检查参数是否完整
    then
        Chat:sendSystemMsg('msg:参数不完整！')
        return 1001
    end
    Trigger:wait(0.1) --一个小的延迟
    if(type(content) ~= "string")--类型转换
    then
        content = tostring(content)
    end
    Chat:sendSystemMsg(content, UIN)
    return 0
end
--在这里的结束标识不会被正确配对
```

---

<!-- _header: 3.4.1.2 多行注释  -->

对于这样的情况 我们可以在两个[[]]之间加上数量相等的=号

```lua
--[=[ 在括号中间加上等号就可以了
--[[对玩家显示聊天框系统消息(重构) 参数是字符串和玩家迷你号
规范化参数避免缺参--]]
local function msg(content, UIN)
    if(content and UIN == nil) --检查参数是否完整
    then
        Chat:sendSystemMsg('msg:参数不完整！')
        return 1001
    end
    Trigger:wait(0.1) --一个小的延迟
    if(type(content) ~= "string")--类型转换
    then
        content = tostring(content)
    end
    Chat:sendSystemMsg(content, UIN)
    return 0
end
--]=]
```

---

<!-- _header: 3.4.2 代码规范  -->

# 代码规范

代码风格一般有三个主要的组成部分 分别是**命名规则** **缩排方式**和**符号处理方式** 这些名词不是专业的名词 只是本喵在编写代码过程中总结出的一些经验

良好的编码风格可以使代码保持美观 便于阅读

命名规则部分 在变量的命名那一节就已经讲过了 所以这一节我们来缩排和符号相关的处理技巧

---

<!-- _header: 3.4.2.1 缩排方式  -->

## 缩排方式

通常 我们将同级的代码写在一个缩进层级上 而将子代码块或子流程缩进一个层级

```lua
local num1 = 10
local num2

if(num2)
then
    print(num1 + num2)
end
```
定义变量的操作和if语句是在同一个执行层级上的 所以它们写在同一个层级上 而print语句是if语句的子流程 所以需要缩进一个层级

一般情况下 选中代码块 按`tab` 或`>` 缩进一个层级 而`shift+tab`或`<`取消缩进
*注: `<` `>`只能在vim中使用*

---

<!-- _header: 3.4.2.2 符号处理方式  -->

## 符号处理方式

在编程中 为了使运算符等符号的书写保持美观 可以遵循以下的规则

- 在运算符的两侧加上空格 `[]`中的符号除外
- 在逗号后加上空格

```lua
--符号前后加上空格
local a = 3
b = a + 3

--逗号后加上空格
local a1, a2, a3 = 3, 4, 5
```

---

<!-- _header: 4. 数值运算 -->

# 第四章 数值运算

---

<!-- _header: 4. 数值运算-目录 -->

> 1. 数值运算符
> 2. 字符串转换方法

---

<!-- _header: 4.1 数值运算符  -->

数值运算符是针对`number`类型的操作符 有如下几种

|符号|名称|备注|
|--|--|--|
|`+`|加||
|`-`|减|也可作负号|
|`*`|乘|$\times$和$\div$不是ascii字符 无法直接通过键盘输入|
|`/`|除|所以乘和除用的是`*`和`/`|
|`%`|取余|对任何精度的数都适用 不要求整数|
|`^`|幂|例如 $3^2$ 在代码中应作`3 ^ 2` 结果为9|
|`//`|整除|Lua5.3后提供 结果会直接舍弃小数部分|

---

<!-- _header: 4.1 数值运算符  -->

## 实例1 数值运算符的使用

以下使用一个小例子来演示每个运算符的用法

```lua
local a, b = 4, 6
print(a + b) -- 10
print(a - b) -- -2
print(a * b) -- 24
print(a / b) -- 0.66666666666667
print(a % b) -- 4
print(a ^ b) -- 4096
print(a // b) --0 请检查自己的lua版本 低于5.3会报错
```

---

<!-- _header: 4.1 数值运算符  -->

## 实例2 倒置四位整数

这里有一个四位数的整数 写代码将其倒置输出

例:

整数为 1314

输出为

```
4
1
3
1
```

---

<!-- _header: 4.1 数值运算符  -->

倒置四位整数 代码

```lua
--定义一个变量存放那个整数
local num = 1024

--分别求其四位
local a = num // 1000 --整除1000求出其最高位
local b = num // 100 % 10 --整除100求出其千位和百位 得到10 再整除10 得到0
local c = num // 10 % 10 --整除10求出其千 百 十位 得到102 再整除10 得到2
local d = num % 10 --整除10得到其最低位

--倒序输出
print(d)
print(c)
print(b)
print(a)
```

---

<!-- _header: 4.2 字符串转换方法 -->

Lua中提供了一些函数 以实现字符串与数值的转换

使用`tonumber()`尝试将字符串转换为数值 如果尝试失败则会得到`nil`

使用`tostring()`可以将大多数类型的数据转换成字符串

```Lua
--将一个字符串转换为数值
local str1 = "-1"
local str1ToNum = tonumber(str1)
--当一个值含有非法字符时 无法转换成数值
local errNum = tonumber("13924awa") --errNum是空值

--将一个其他类型的值转换为字符串
print(tostring(a)) -- a没有被定义过 会得到"nil"
print(tostring(true)) --得到 "true"
```

---

<!-- _header: 5. 流程控制与布尔值运算  -->

# 第五章 流程控制与布尔值运算

---

<!-- _header: 5. 流程控制与布尔值运算-目录  -->

> 1. 流程控制
>       1. 单分支
>       2. 双分支
>       3. 多分支
>       4. `if`语句的嵌套
> 2. 布尔值运算
>       1. 布尔值运算符
>       2. 比较运算符
>       2. 流程控制时的自动转换
>       3. `or`的特殊用途

---

<!-- _header: 5.1 流程控制  -->

# 流程控制

在现实中 我们可能会有这样一些经历:

我想吃鱼 或是猪肉 如果集市上有卖鱼 我就吃鱼 不然我就去买猪肉吃

<pre class="mermaid">
graph LR

A(今天吃什么) --> B{市场有没有鱼}
B --有--> C(我买鱼)
B --没有--> D(我买猪肉)

</pre>

执行买鱼还是买猪肉 这取决于市场上有没有鱼 这就是条件判断与流程控制

在Lua中 可以使用`if`语句来实现流程控制

---

<!-- _header: 5.1 流程控制  -->

`if`语句的结构如下

```Lua
if(条件)
then --语句开始的标志
    --条件为真是执行的内容
end --语句结束的标志
```

条件也可以不用括号括起来 如下
```lua
if 条件 then
    --条件为真时执行的语句
end
```

---

<!-- _header: 5.1.1 单分支  -->

## 单分支

单分支是只有在条件成立的情况下做指定的动作 若条件不成立 就什么都不做 例如:

<pre class="mermaid">
graph LR

A(要不要吃东西) --> B{我现在饿不饿} --饿了--> C(吃东西)

</pre>

此逻辑可以用以下代码表示 两个代码只是写法不同 逻辑是相同的

<div class="columns">
<div>

```lua
local isHungry = true

if(isHungry)
then
    print("我吃点东西")
end
```

</div>
<div>

```lua
local isHungry = true

if isHungry
then
    print("我吃点东西")
end
```

</div>
</div>

---

<!-- _header: 5.1.2 双分支  -->

## 双分支

双分支是判断一个条件 若条件为真 执行指定的动作 若条件为假 执行另一指定的动作

<pre class="mermaid">
graph LR

A(我想玩游戏) --> B{作业写完了吗}
B --写完了--> C(我去玩游戏)
B --没有写完--> D(我去写作业)

</pre>

---

<!-- _header: 5.1.2 双分支  -->

可以用下面的代码来实现这个逻辑

<div class="columns">
<div>

```lua
local homeworkFinishment = true

if(homeworkFinishment)
then
    print("作业完成了 可以玩游戏了")
else
    print("作业没有写完 继续写作业")
end
```

</div>
<div>

```lua
local homeworkFinishment = true

if homeworkFinishment
then
    print("作业完成了 可以玩游戏了")
else
    print("作业没有写完 继续写作业")
end
```

</div>
</div>

---

<!-- _header: 5.1.3 多分支  -->

## 多分支

当动作由多个条件所决定时 我们需要用到多分支 例如

如果用户输入的是A 调整其移动速度 如果是B 调整其模型大小 如果是C 调整其血量 如果是其他的 输出一条提示信息

<pre class="mermaid">
graph TB

B(判定玩家输入)

B --A--> C(调整移动速度)
B --B--> D(调整模型大小)
B --C--> E(调整血量)
B --其他--> F(输出一条提示信息)


</pre>

---

<!-- _header: 5.1.3 多分支  -->

```lua
local input = "A"

if(input == "A") -- ==是比较运算符 在下一节会讲到 这里是比较两者是否相等
then
    print("调整移动速度") --我们还没有学到游戏内的逻辑 所以这里用输出字符串来代替
elseif(input == "B")
then
    print("调整模型大小")
elseif(input == "C")
then
    print("调整血量")
else
    print("没有这个动作")
end
```

注意 只要上面的语句中含有`if` 例如`if`和`elseif` 下面都要加`then` 而`else`不需要加`then` 只要直接写要执行的语句即可

---

<!-- _header: 5.1.4 if语句的嵌套  -->

## `if`语句的嵌套

嵌套是指一个语句嵌入到另一个语句中 作为其子语句

在生活中 我们可能遇到这样的场景:  
如果下雨 我就在家里 否则我去网吧
当我在家里时 如果我饿了 我就去做饭吃 否则我去睡觉

<pre class="mermaid">
graph LR

A(我要不要去网吧) --> B{有没有下雨}
B --下雨了--> C(待在家里)
B --没有下雨--> D(去网吧)
C --> E{现在饿不饿}
E --饿了--> F(做饭吃)
E --不饿--> G(睡觉去)

</pre>

---

<!-- _header: 5.1.4 if语句的嵌套  -->

```lua
local rain = true
local hungry = false

--先判断是否下雨
if(rain)
then
    print("待在家里")
    --再判断是否饥饿
    if(hungry)
    then
        print("做饭吃")
    else
        print("睡觉去")
    end
else
    print("去网吧")
end
```

---

<!-- _header: 5.2 布尔值运算  -->

# 布尔值运算

在本节中 会介绍两种运算符 分别是布尔值运算符和比较运算符

---

<!-- _header: 5.2.1 布尔值运算符  -->

## 布尔值运算符

布尔值运算符总共有三个 分别是`and` `or`和`not` 它们的操作数是布尔值类型的数据 或者可以转换为布尔值的数据 在这些运算符中 `and`和`or`是双目运算符 而`not`是单目运算符

运算符的**目**是指其操作数的个数 双目就是有两个操作数 如`+` 一个操作数在其左边 另一个在右边 如`A + B` 而`-`在表示减号的时候是双目运算符 和`+`一样 但在表示负号的时候 是单目运算符 如`-1`

`and`表示与 `or`表示或 `not`表示非

---

<!-- _header: 5.2.1 布尔值运算符  -->

<div class="columns">
<div>

**and的运算结果**
|第一个操作数|第二个操作数|结果|
|--|--|--|
|true|true|true|
|false|true|false|
|true|false|false|
|false|false|false|

只要有一个操作数为假 结果为假

</div>
<div>

**or的运算结果**
|第一个操作数|第二个操作数|结果|
|--|--|--|
|true|true|true|
|false|true|true|
|true|false|true|
|false|false|false|

只要有一个操作数为真 结果为真
</div>
</div>

---

<!-- _header: 5.2.1 布尔值运算符  -->

**`not`的运算结果**

|操作数|结果|
|--|--|
|true|false|
|false|true|

<br/>

`not`运算符比较特别 它会直接将它后面的操作数取反

---

<!-- _header: 5.2.1 布尔值运算符  -->

## 应用实例

以下是一个例子来说明这三个运算符的用法

```lua
local a, b = true, false

local c = a and b --c为false
local d = a or b --d为true

local e = not a --e为false
local f = not b --f为true
```

---

<!-- _header: 5.2.2 比较运算符  -->

## 比较运算符

比较运算符是用来判断两边的操作数是否相等的 它会返回一个布尔值

比较运算符都是双目运算符

---

<!-- _header: 5.2.2 比较运算符  -->

比较运算符有以下这些

|符号|名称|备注|
|--|--|--|
|==|等于|用来判断两边的操作数是否相等 **千万不要写成`=`!!!**|
|>=|大于等于||
|<=|小于等于||
|<|小于||
|>|大于||
|~=|不等于|不要写成`!=` 这是其他编程语言中的写法|

---

<!-- _header: 5.2.2 比较运算符  -->

`==` 和`~=`可以比较任意类型的数据 如字符串 布尔值等

而其他的比较运算符只能比较数值类型的数据

```lua
local str = "awa"

--前面的=是赋值符号 后面的那个==是比较运算符 strResult中的结果是true
local strResult = str == "awa"

local a = 3
local b = a <= 2 --b为false 因为3不小于等于2
```

---

<!-- _header: 5.2.2 比较运算符  -->

### 比较运算符在流程控制中的运用

当我们需要求一个条件是否成立时 比较运算符是非常有用的工具

例如 代表年龄的字段是一个数值 我们可以用一个比较运算符来判定一个人是否成年

```lua
local age = 20

if(age >= 18)
then
    print("你成年了")
else
    print("你还没成年")
end
```

---

<!-- _header: 5.2.2 比较运算符  -->

在多条件的选择下的例子

今晚吃什么 取决于家里还有什么 假设家里只有一样食物(猪肉 鱼 和鸡蛋三者之一)

```lua
local food = "猪肉"

if(food == "猪肉")
then
    print("小炒肉")
elseif(food == "鱼")
then
    print("红烧鱼")
elseif(food == "鸡蛋")
then
    print("蛋炒饭")
else
    print("没有食材了 下馆子吧")
end
```

---

<!-- _header: 5.3 流程控制时的自动转换  -->

# 流程控制时的自动转换

`if`语句的条件是一个布尔值 但是如果用户给定的值不是布尔值 它会自动将`nil`转换为`false` 而将其他类型的数据转换成`true`

我们可以用这个机制来判断一个变量是否存在值

```lua
local a --声明一个变量a 不赋值

if(a)
then
    print("a存在")
else
    print("a不存在")
end
```

---

<!-- _header: 5.4 or的特殊用途  -->

# `or`的特殊用途

`or`不仅仅可能在布尔值运算中使用 还可以在创建变量时为变量赋默认值

```lua
local my_name = "欧阳闻奕"

local name = my_name or "无名者"

print(name)
```

在上面的例子中 如果`my_name`为空值 `name`就会使用默认值"无名者"

使用`or`而不是使用`if`判断后赋默认值有这些好处:

- 代码简洁
- 代码意图清晰

---

<!-- _header: 6. 循环  -->

# 第六章 循环

----

<!-- _header: 6. 循环-目录  -->

> 1. while循环
> 2. for循环
> 3. repeat...until循环
> 4. break
> 5. 循环嵌套

---

<!-- _header: 6. 循环  -->

重复执行某些动作直到达成退出条件的操作称作循环

例如 上体育课 需要在操场跑圈圈 老师说 跑五圈就可以休息了 用流程图表明这个逻辑 如下

<pre class="mermaid">
graph LR

A(去操场跑5圈) --进入操场--> B(跑一圈) --> C{判断有没有完成5圈}

C --完成了--> D(去休息)
C --没有完成--> B

</pre>

在lua中 有`while`循环 `for`循环和`repeat...until`循环

---

<!-- _header: 6.1 while循环  -->

# `while`循环

`while`循环的结构如下 条件可用括号可不用括号

<div class="columns">
<div>

```lua
while(--[[条件]])
do
    --条件成立时执行的语句
end
```

</div>
<div>

```lua
while --[[条件]]
do
    --条件成立时执行的语句
end
```

</div>
</div>

`while`循环由两部分构成 分别为条件和循环休(即条件成立时循环执行的语句) 每执行一次条件时都需要判断条件是否成立 若条件成立 则执行循环体 否则 跳出循环

---

<!-- _header: 6.1 while循环  -->

## 使用`while`循环来实现跑圈圈的逻辑

```lua
local count = 0

while(count < 5)
do
    print("我跑了一圈")
    --跑一圈 把计数加1
    count = count + 1
    -- ..是连接字符串的符号 在字符串章节会详细说明
    print("我已经完成了" .. count .. "圈")
end

print("我跑完了")
```

---

<!-- _header: 6.2 for循环 -->

# `for`循环

`for`循环的形式如下

```lua
for --[[变量名]] = --[[起始位置]], --[[结束位置]], --[[步长]]
do
    --循环体
end
```

起始位置是进入循环时 变量初始的值 每次循环后 变量会加上步长 直到变量达到结束位置的值 步长可以省略 缺省的情况下 默认为1

在循环中 通常我们用`i` `j` `k`等字母来代表循环变量

---

<!-- _header: 6.2 for循环 -->

一个通常的for循环是这样的
```lua
for i = 1, 10 --这里的步长不写 默认为1
do
    print(i)
end
```

将变量`i`从1循环加到10 每做一次循环都会使`i`加1

---

<!-- _header: 6.2 for循环 -->

### `for`循环解决跑圈问题

```lua
for i = 1, 5
do
    print("我跑了" .. i .. "圈")
end

print("我跑完了")
```

这里与`while`循环不同 是从1到5 而且循环会自动将变量自加 无需手动去写

```lua
i = i + 1
```

总体来说 `for`循环是我们使用频率最高的循环形式

---

<!-- _header: 6.3 repeat...until循环 -->

# `repeat...until`循环

`repeat...until`循环的写法如下

```lua
repeat
    --循环体
until(--[[约束]])
```

通常形式如下 这会从1输出到4
```lua
local i = 1

repeat
    print(i)
    i = i + 1
until(i > 4)
```

---

<!-- _header: 6.3 repeat...until循环 -->

进入循环后 会先执行循环体一次 然后判断约束中的值: 若约束条件为真 就退出循环 否则继续循环

与`while`循环和`for`循环不同 `repeat...until`循环至少执行一次循环体 因为其他循环是先判断条件 而`repeat...until`循环是先执行再判断

而且 其他循环是条件为假时退出 而`repeat...until`循环是条件为真时退出 因为`until`是"直到"的意思 循环直到条件为真

`repeat...until`循环没有类似其他循环的`do...end`结构

---

<!-- _header: 6.3 repeat...until循环 -->

### 跑圈圈问题

```lua
local i = 0

repeat
    i = i + 1
    print("我跑了" .. i .."圈")
until(i == 5)
```

---

<!-- _header: 6.4 break -->

# `break`

在循环中 有时候我们需要提前跳出循环 或者在一个没有退出条件的循环中 需要跳出循环 我们可以用`if`语句搭配`break`来进行跳出循环的操作

例如 我们做一个随机数生成器 当生成的数大于100时 退出循环

```lua
while(true) --条件永远为真 循环不会结束 这是一个死循环
do
    --在1到200这个区间生成一个随机数 并存放在变量中
    local ranNum = math.random(1, 200)

    --如果生成的数大于100 使用break退出循环
    if(ranNum > 100)
    then
        break
    end
end
```

---

<!-- _header: 6.5 循环嵌套 -->

# 循环嵌套

在一些场景中 我们可以使用两重循环甚至多重循环来实现一些功能 比如输出一个**三行四列的行列式**

```lua
local count = 0

for i = 1, 3
do
    local str = ""
    for j = 1, 4
    do
        str = str .. count .. " "
        count = count + 1
    end
    print(str)
end
```

---

<!-- _header: 7. 字符串操作  -->

# 第七章 字符串操作

---

<!-- _header: 7. 字符串操作-目录  -->

> 1. 求字符串长度
> 2. 转义字符
> 3. 各种常用操作

---

<!-- _header: 7.1 求字符串长度 -->

# 求字符串长度

可以使用`#` 或`string.len(str)`来求字符串的长度

实例如下

```lua
local str1 = "hello world"
local str1len = #str1
print(str1len)

local str2 = "goodbye world"
local str2len = string.len(str2)
print(str2len)
```

---

<!-- _header: 7.2 转义字符 -->

# 转义字符

字符串是由`""` `''` 或`[[]]`包围形成的 而前面的这些符号在字符串中直接打出来 会导致错误 如果想要在字符串中包含这些字符的话 我们要怎么办呢 转义字符可以解决这个问题

还有一些常见的操作 如换行 制表符 也可以通过转义字符实现

---

<!-- _header: 7.2 转义字符 -->

常用的转义字符有以下这几种

|转义字符|含义|
|--|--|
|\n|换行|
|\t|水平制表符|
|\v|垂直制表符|
|\0|空字符|
|`\` + `'` `"` `\` `[` `]`|代表`\`后面的字符|
|\ddd|表示一个八进制形式编码的ascii字符|
|\xXX|表示一个以十六进制编码的ascii字符|
|\u{X}|表示一个Unicode字符 `X`是一个或多个十六进制数字|

---

<!-- _header: 7.2 转义字符 -->

## 示例用法

可以在字符串中间加入一个`\n` 将其换行

```lua
local awa = "喵喵喵\n小猫不能上电脑桌!"
```

使用`\`加上那些打不出来的字符 可以将它们插入到字符串中

```lua
local str = "老大说过: \"你还是太年轻了\""
```

---

<!-- _header: 7.2 转义字符 -->

```lua
local str = "Hello\tWorld"  -- 水平制表符
print(str)

--ascii字符示例
local str = "Hello\97World"  -- 八进制表示（\97 表示字符 'a'）
print(str)
local str = "Hello\x61World"  -- 十六进制表示（\x61 表示字符 'a'）
print(str)
local str = "Hello\u{61}World"  -- Unicode 码点表示（\u{61} 表示字符 'a'）
print(str)
```

---

<!-- _header: 7.2 转义字符 -->

## ASCII字符

ASCII（发音：阿斯奇）是英文 "American Standard Code for Information Interchange" 的缩写，意思是“美国信息交换标准代码”。它是一种用来表示文本字符的编码标准。每个 ASCII 字符都由一个数字表示，计算机可以通过这些数字来理解和显示字符。

ASCII 表包含了 128 个字符，每个字符对应一个从 0 到 127 的数字。这里有一些常见的 ASCII 字符及其对应的数字：

- 数字 0 到 9：字符 '0' 到 '9'，对应的数字是 48 到 57
- 大写字母 A 到 Z：字符 'A' 到 'Z'，对应的数字是 65 到 90
- 小写字母 a 到 z：字符 'a' 到 'z'，对应的数字是 97 到 122
- 特殊符号：例如空格（32）、感叹号（33）、引号（34）、#（35）、$（36）等等

---

<!-- _header: 7.2 转义字符 -->

## 利用转义字符排版九九乘法表

做出如下这样的乘法表

```
1*1=1
1*2=2   2*2=4
1*3=3   2*3=6   3*3=9
1*4=4   2*4=8   3*4=12  4*4=16
1*5=5   2*5=10  3*5=15  4*5=20  5*5=25
1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36
1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49
1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64
1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81
```

`\t`是水平制表符 通常为四个空格的宽度 可以使输出的字符保持整齐

---

<!-- _header: 7.2 转义字符 -->

```lua
--从1到9 这是第一层循环
for i = 1, 9
do
    --定义一个空的字符串
    local str = ""
    --从1 遍历到当前循环可用的数
    for j = 1, i do
        --每遍历到一个 就将其加入字符串的尾部
        --最后那个\t可以保证输出内容排列整齐
        str = str .. j .. "*" .. i .. "=" .. i * j .. "\t"
    end

    --跳出循环后 输出刚刚处理好的字符串
    print(str)
end
```

---

<!-- _header: 7.3 字符串常用操作 -->

# 字符串常用操作

在本节中 会对字符串中较难和较常用的操作做详细的说明 并简要介绍一些不常用的操作

<div class="columns">
<div>

### 简要介绍

- 连接
- 大小写转换
- 截取
- 查找
- 反转

</div>
<div>

### 详细介绍

- 格式化字符串
- 正则表达式截取

</div>
</div>

此处只是介绍常用操作 想要了解更多 详见[菜鸟教程](https://www.runoob.com/lua/lua-strings.html) 或[w3cschool](https://www.w3cschool.cn/lua/lua-strings.html)

---

<!-- _header: 7.3.1 简要介绍 -->

## 简要介绍

### 连接

使用两个点`..`可以连接字符串 字符串本身是一个常量 任何操作都不会改变字符串本身 而是创建一个新的字符串 例如

```lua
local a, b = "hello", "world"
local c = a .. b --这将生成一个新的字符串 放入c中

print(c)
print(a) --可以看到 a和b都还是原来的值
print(b) --不会改变原变量中的字符串 除非为它们重新赋值 像下面这样

a = a .. b
print(a)
```

---

<!-- _header: 7.3.1 简要介绍 -->

### 大小写转换

使用`string.upper()` 和`string.lower`可以将字符串转换为大写或小写

```lua
local a = "hello world"
local b = "GOODBYE WORLD"

upper_a = string.upper(a)
lower_b = string.lower(b)

print(a)
print(b)
```

---

<!-- _header: 7.3.1 简要介绍 -->

### 截取

string.sub(str, i, j) `str`为待截取的字符串 `i`为起始位置 `j`为结束位置 `j`可省略 缺省情况下默认截取到字符串结尾

```lua
local str = "Miniworld"
local substr = string.sub(str, 1, 4)
print(substr)
```

### 查找

string.find(str, substr, i, plain) `str`为原字符串 `substr`为待查找的子串 `i`代表起始位置 `plain`为一个布尔值 若为`false` 则使用正则表达式匹配 `i` 和`plain`可省略

---

<!-- _header: 7.3.1 简要介绍 -->

查找的示例

```lua
local str = "Escape Meta Alt Control Shift" --emacs残害了无数用户的小指
local alt_location = string.find(str, "Alt")
print(alt_location) --这会输出一个数字
```

### 反转

使用string.reverse(str)来反转一个字符串

```lua
print(string.revrese("hello"))
```

---

<!-- _header: 7.3.2 格式化字符串 -->

## 格式化字符串

让我们回顾乘法表的代码

```lua
for i = 1, 9
do
    local str = ""
    for j = 1, i do
        str = str .. j .. "*" .. i .. "=" .. i * j .. "\t"
    end
    print(str)
end
```

在这个代码中 我们使用了字符串连接符来串连各元素 使其组成完整的字符串 这样可读性差且容易出错 那么 有什么方法可以使各变量的值轻松插入到字符串中呢

可以用字符串格式化 string.format(formatstr, ...) `formatstr`是模板字符串 后面是参数列

---

<!-- _header: 7.3.2 格式化字符串 -->

string.format 和C语言中的printf()很像 它的第一个参数为格式 后面的参数会替换格式串中的占位符

```lua
local a, b = 1, 2
str = string.format("%d+%d=%d", a, b, a + b)
```

运行以上代码 会输出: 1+2=3

`%d`是一个占位符 代表一个整数  在上面的例子中 格式串中有三个`%d` 在执行格式化的时候 后面的三个变量中的数值会被放到占位符的位置 形成完整的字符串

---

<!-- _header: 7.3.2 格式化字符串 -->

<div class="columns">
<div>

<br/>
<br/>

常用的占位符如右表 但最常用的还是

`%d` `%f` `%s`

```lua
local name = "欧阳闻奕"
local age = "13"
local height = 139.24

local msg = string.format([[
我的名字是%s
今年%d岁
身高%fcm
]], name, age, height)

print(msg)
```

</div>
<div>

|占位符|含义|
|--|--|
|%d|一个十进制整数|
|%o|一个八进制数|
|%u|一个无符号数|
|%x|十六进制数 使用小写字母|
|%X|十六进制数 使用大写字母|
|%e|科学计数法 使用小写字母e|
|%E|科学计数法 使用大写字母E|
|%f|一个浮点数 也就是小数|
|%g(%G)|使用%e或%f中较短的一种|
|%s|一个字符串|

</div>
</div>

---

<!-- _header: 7.3.2 格式化字符串 -->

优化乘法表代码

```lua
for i = 1, 9
do
    local str = ""
    for j = 1, i do
        --str = str .. j .. "*" .. i .. "=" .. i * j .. "\t"
        str = str .. string.format("%d*%d=%d\t", j, i, i * j)
    end
    print(str)
end
```

将原先的代码注释掉 改成格式化字符串的形式

---

<!-- _header: 7.3.2 格式化字符串 -->

### 占位符细节

在字符串格式化中 可以在占位符的%后加上一些字符来指定其格式化的细节

1. **指定宽度和补零**

   - `%4d`：表示格式化为至少 4 位的十进制整数。如果数字不足 4 位，则在前面补空格。
   - `%04d`：表示格式化为至少 4 位的十进制整数。如果数字不足 4 位，则在前面补零。

   ```lua
   print(string.format("%4d", 5))    -- 输出 "   5"
   print(string.format("%04d", 5))   -- 输出 "0005"
   ```

---

<!-- _header: 7.3.2 格式化字符串 -->

2. **指定宽度和对齐方式**

   - `%10s`：表示格式化为至少 10 个字符的字符串。如果字符串不足 10 个字符，则在前面补空格。
   - `%-10s`：表示格式化为至少 10 个字符的字符串。如果字符串不足 10 个字符，则在后面补空格（左对齐）。

   ```lua
   print(string.format("%10s", "hi"))  -- 输出 "        hi"
   print(string.format("%-10s", "hi")) -- 输出 "hi        "
   ```

3. **指定精度**

   - `%.2f`：表示格式化为浮点数，并保留 2 位小数。
   - `%6.2f`：表示格式化为至少 6 个字符的浮点数，并保留 2 位小数。如果数值不足 6 个字符，则在前面补空格。

   ```lua
   print(string.format("%.2f", 3.14159))   -- 输出 "3.14"
   print(string.format("%6.2f", 3.14159))  -- 输出 "  3.14"
   ```

---

<!-- _header: 7.3.2 格式化字符串 -->

### 综合示例

```lua
local year, month, day = 1995, 3, 6
-- 格式化为 YYYY/MM/DD
local formatted_date = string.format("%04d/%02d/%02d", year, month, day)
print(formatted_date)  -- 输出 "1995/03/06"

-- 更多示例
print(string.format("%4d", 7))    -- 输出 "   7"
print(string.format("%04d", 7))   -- 输出 "0007"
print(string.format("%-10s", "hi")) -- 输出 "hi        "
print(string.format("%.3f", 3.14159))   -- 输出 "3.142"
```

---

<!-- _header: 7.3.3 正则表达式截取 -->

## 正则表达式截取

在游戏中 有时需要处理玩家输入的指令逻辑 其中有指令和参数 脚本收到时是完整的一个字符串 我们要如何将指令的各部分提取出来呢

例如 要实现一个玩家传送逻辑 设计的指令格式为`/to x y z` 其中`x` `y` `z`是坐标

假如我想传送到(43, 67, 103) 我应该输入`/to 43 67 103`

为了从这个字符串中提取参数 我们可以使用string.match() 配合正则表达式来截取

当然 正则表达式可以在string.find() string.gmatch() string.gsub()等函数中使用

---

<!-- _header: 7.3.3 正则表达式截取 -->

经过观察 传送命令是由`/`开头 后面是一个字符串 代表命令 再后面是三个以空格隔开的整数 所以 我们可以这样截取它

```lua
local str = "/to 43 67 103"

--截取其第一个字符 若是/ 就是命令
local head = string.sub(str, 1, 1)
if(head == "/")
then
    local pattern = "/(%a+)%s(%d+)%s+(%d+)%s+(%d+)"
    local order, x, y, z = string.match(str, pattern)
    print(order, x, y, z)
end
```

在代码中 定义了一个正则表达式字符串`pattern` 然后使用string.match按照正则表达式的形式来捕获字符串中的各参数

<!-- 玩家会输入很多内容 所以需要做一个过滤 如果不是命令 就不让其进入到逻辑中 -->

---

<!-- _header: 7.3.3 正则表达式截取 -->

在上一页中 命令的形式是`/to 43 67 103` 正则表达式的形式是

```lua
"/(%a+)%s(%d+)%s+(%d+)%s+(%d+)"
```

其中开头的`/`会匹配命令开头的`/`

`%a`会匹配任意字母 `%a+`代表与尽量长的字母串配对

`%d`会与整数配对 `%s`会与空格配对 它们后面都有`+` 代表找到尽可能长的匹配串

每个用括号框起来的模式 代表一个捕获物 就是我们需要的部分 它将会在截取后返回给变量

---

<!-- _header: 7.3.3 正则表达式截取 -->

### 匹配模式

<div class="columns">
<div>

|字符|匹配对象|例子|
|--|--|--|
|单个字符|自身|`/`|
|.|任何字符||
|%a|字母||
|%c|控制符|`\n` `\t`|
|%d|数字||
|%l|小写字母||

</div>
<div>

|字符|匹配对象|例子|
|--|--|--|
|%p|标点||
|%s|空格||
|%u|大写字母||
|%w|数字与字母||
|%x|十六进制数值||
|%z|代表0的字符|

</div>
</div>

参考自[菜鸟教程](https://www.runoob.com/lua/lua-strings.html)

---

<!-- _header: 7.3.3 正则表达式截取 -->

### 特殊的匹配类

[数个字符类] 与任何[]中的类匹配 如[%a%s%c]可以与字母 空格和控制符匹配

[^数个字符类] 如[^%d] 与任何非数字匹配

%`特殊字符` 匹配特殊字符自身

**以上所有字符类中的字母用大写时 表示与非此字符类的字符匹配 如`%S`代表与非空格字符匹配 等价于`[^%s]`**

特殊字符有`(` `)` `.` `%` `+` `-` `*` `?` `[` `^` `$` 它们有自己特殊的用法 如果要匹配他们本身 需要在前面加上`%`使其转义 就像在字符串中想加入`"` `'` `[` `]`等符号一样 不过字符串中是使用`\`进行转义

参考自[菜鸟教程](https://www.runoob.com/lua/lua-strings.html)

---

<!-- _header: 7.3.3 正则表达式截取 -->

### 特殊符号的含义

- **()** 表示一个掳获物
- **\*** 单个字符类加上\* 表示匹配0或多个字符 且匹配尽可能长的字符串
- **+** 单个字符类加上+ 表示匹配0或多个字符 且匹配尽可能长的字符串
- **-** 单个字符类加上- 表示匹配0或多个字符 且匹配尽可能短的字符串
- **?** 单个字符类加上? 表示匹配0个或1个字符 例如`%s?` `-?`

参考自[菜鸟教程](https://www.runoob.com/lua/lua-strings.html)

---

<!-- _header: 7.3.3 正则表达式截取 -->

### 优化传送指令

我们通过实现传送指令的截取认识了正则表达式 那么 刚刚肯定有没考虑到的地方 例如 迷你世界中的x坐标和z坐标可能为负数 如果玩家输入了负数 刚刚那个截取的逻辑就会出错 我们可以用后来学习到的知识来完善这个逻辑

```lua
local str = "/to -43 67 103" --将参数中的值改成负数以测试

local head = string.sub(str, 1, 1)
if(head == "/")
then
    --local pattern = "/(%a+)%s(%d+)%s+(%d+)%s+(%d+)"
    local pattern = "/(%a+)%s(%-?%d+)%s+(%-?%d+)%s+(%-?%d+)"
    local order, x, y, z = string.match(str, pattern)
    print(order, x, y, z)
end
```

加入了`%-?`来匹配0或1个-号 就可以匹配负数了

---

<!-- _header: 7.3.3 正则表达式截取 -->

### 后续处理

在正则表达式截取后 得到的捕获物全是字符串类型 如果要将其做特定用途(如作为传送玩家的坐标等) 必须进行格式转换 如用`tonumber()`进行处理

### 定心丸

正则表达式部分虽然较难理解 但是在游戏中不常用 主要是做指令时会用到

如果仅做地图逻辑开发方面 各位对其有一个基础了解即可 需要用到时去查找参考文档 根据示例来做 并且自己多尝试 大概可以解决大部分问题

无需担心自己对本节内容理解不深

---

<!-- _header: 8. 表  -->

# 第八章 表

---

<!-- _header: 8. 表-目录 -->

> 1. 表的构造
>       1. 数组形式的表
>       2. 键值对形式的表
> 2. 字符串作为索引时的语法糖
> 3. 增加 删除表中元素
> 4. 求表的长度
> 5. 遍历一个表
>       1. for
>       2. 迭代器
> 6. 各种常用操作
> 7. 关于表的元素为引用传递的说明
> 

---

<!-- _header: 8.1 表的构造 -->

# 表的构造

**表(table)** 是lua中的一个复杂数据类型 它有数组形式和键值对形式

它是一个很强大的数据结构 Lua中 数组 哈希表 面向对象的功能都可以用表实现

构造一个表 可以用一对大括号实现 如下是构造一个空的表

```lua
local myTable = {}

local tp = type(myTable) --使用type检测其类型
print(tp) --会输出table
```

---

<!-- _header: 8.1.1 数组形式的表 -->

## 数组形式的表

数组是一串数据的结合体 数组中的成员称为元素 在某些编程语言中 要求数组中所有数据是相同的数据类型(如C/C++) 但是在Lua语言中没有此要求 然而 数组在实际应用中还是更常用于存放一组类型相同的数据

要构造一个数组 只需要将数据用逗号`,`隔开放在一个表中即可

要索引一个数组中的元素 使用中括号`[]`加上数字即可索引

```lua
local myArray = {10, 24, 32, 48, 56}

print(myArray[3]) --输出32
```

*lua中的数组索引是从1开始的*

---

<!-- _header: 8.1.1 数组形式的表 -->

当然 数组的成员不仅仅可以是普通的数据类型 还可以是表和函数等等

这里演示一个二维数组

```lua
local myArray = {
    {11, 22, 33, 44},
    {55, 66, 77, 88},
}

--可以通过双重索引来访问到其中的元素
print(myArray[2][3]) --输出77
```

可以根据需求创建三维甚至更多维度的数组

---

<!-- _header: 8.1.2 键值对形式的表 -->

## 键值对形式的表

在数组中 表的索引是从1开始的数字 其实我们可以自定义表的索引 使用`[]`框住一个值 作为该元素的索引 索引可以是任何简单数据类型 或是变量中的值

注意: 索引不可以是`nil` !

```lua
local awa = "喵喵喵"
local myTable = {[4.5] = 20, [true] = 5, [awa] = 3, ["cat"] = "meow"}

print(myTable[4.5])
print(myTable["cat"])
```

---

<!-- _header: 8.1.2 键值对形式的表 -->

为了使表看起来美观清晰 我们可以对其进行排版

```lua
local awa = "喵喵喵"
local myTable = {
    [4.5] = 20,
    [true] = 5,
    [awa] = 3,
    ["cat"] = "meow",
}
```

最后一条的逗号可以加可以不加 不影响整体运行 但是前面每条的末尾必须加逗号

---

<!-- _header: 8.2 字符串作为索引时的语法糖 -->

# 字符串作为索引时的语法糖

在键值对形式的表中 最常用的索引形式是字符串 例如创建一个关于人物的表

```lua
local person = {
    ["name"] = "OWALabuy",
    ["age"] = 13,
    ["height"] = 139,
    ["skill"] = {
        "cooking",
        "programming",
        "music",
    },
}

print(person["name"])
```

在使用字符串作为索引时 需要用`[]`和`""`把字段框起来 显得非常臃肿 且输入麻烦

---

Lua中提供了一种语法糖来简化这个操作

<br/>

<div class="columns">
<div>

当表的索引为字符串时 我们可以直接写这个字符串 而不使用中括号和引号

```lua
local person = {
    name = "OWALabuy",
    age = 13,
    height = 139,
    skill = {
        "cooking",
        "programming",
        "music",
    }
}
```

</div>
<div>

在访问这些数据时 可以用`.`加上这个字段

```lua
--以下这两条是完全等价的
print(person.name)
print(person["name"])

--语法糖可以与中括号同时使用
print(person.skill[2])
print(person["skill"][2])
```

**注意: 这个语法糖仅在索引为字符串时可用 它是固定的 而如果要使用变量中的数据为表的成员创索引或访问数据 应该加上`[]`**

---

<!-- _header: 8.3 增加 删除表中元素 -->

# 增加 删除表中元素

表中的元素不仅仅可以在初始的时候给定 后期还能动态地插入 表是不定长度的

直接指定其索引和值即可为表添加新元素 为已存在的索引赋新的值可改变其值

```lua
local myTable = {11, 22, 33}

myTable[4] = 44

--原有的元素和新增的元素都能被正常访问
print(myTable[2])
print(myTable[4])

--修改其索引中的值
myTable[2] = 24
print(myTable[2])
```

---

<!-- _header: 8.3 增加 删除表中元素 -->

想要删除一个元素 直接向其索引赋值`nil`

```lua
local myTable = {11, 22, 33}

print(myTable[2])

--删除一个元素
myTable[2] = nil

print(myTable[2])
```

---

<!-- _header: 8.4 求表的长度 -->

# 求表的长度

对于数组形式的表 可以用`#`来求其长度 会得到其元素的个数

```lua
local myTable = {
    cat = {"eat", "play", "sleep"},
    dog = {"owner", "love", "eat", "walking"}
}

print(#myTable) --是2 因为其中有cat和dog两个元素
print(#myTable.cat) --是3 cat是一个表 其中有三个字符串作为它的元素
```

注意 如果数组形式的表中有断点 这个方法会返回断点处的值 而不是完整的表长 但是一般的数组形式的表不会出现断点 不考虑这个问题

---

<!-- _header: 8.5 遍历一个表 -->

# 遍历一个表

想要遍历一个表 可以采用两种方法遍历 `for`循环和迭代器

实际上`while`循环和`repeat...until`循环也可以实现遍历的效果 但是远不如`for`循环方便 所以如果需要有序遍历一个表 通常的选择是`for`循环

而迭代器常用在表的索引不是数值的情况下 如哈希表

---

<!-- _header: 8.5.1 for循环 -->

## for循环

对于一个数组 我们会用`for`循环去遍历它 例如

```lua
local myArray = {13, 92, 46, 17, 1}

--从1到数组的长度 进行遍历
for i = 1, #myArray
do
    print(myArray[i])
end
```

以上例子展示了遍历一维数组 并输出每个元素 如果要遍历更高维的数组 可以使用循环嵌套

---

<!-- _header: 8.5.2 迭代器 -->

## 迭代器

迭代器分为两种 分别是`pairs()`和`ipairs()` 它们的写法如下

<div class="columns">
<div>

```lua
local t = {11, 22, 33}
t.a1 = "a1"

for index, value in ipairs(t) do
    print(index, value)
end
```

</div>
<div>

```lua
local t = {11, 22, 33}
t.a1 = "a1"

for key, value in pairs(t) do
    print(key, value)
end
```

</div>
</div>

以上的例子中 表包括数组部分和键值对部分 添加了`a1`字段作为它的键值对部分

`ipairs`和普通的for循环一样 只会遍历数组部分 而不会遍历到哈希部分(键值部分)

而`pairs`可以遍历完整的表 逐个读取元素的键和值 不管是不是数字作为索引

---

<!-- _header: 8.5.2 迭代器 -->

在迭代器中 变量的名字是可以自己定义的 刚刚的例子中是这样写的

```lua
for key, value in pairs(t) do
    print(key, value)
end
```

也可以把那些变量的名字改成你喜欢的值

```lua
for k, v in pairs(t) do
    print(k, v)
end
```

---

<!-- _header: 8.6 常用操作 -->

# 常用操作

本节将介绍一些关于数组形式的表的常用操作 当这些操作的对象是有数组部分也有哈希部分的表时 只会对数组部分生效

1. 连接
2. 插入
3. 删除
4. 排序

本节内容参考自[菜鸟教程](https://www.runoob.com/lua/lua-tables.html)

---

<!-- _header: 8.6.1 连接 -->

## 连接

可以用`table.concat(table, sep, start, end)`来使一个数组形式的表变成一个字符串 方便我们进行预览 `table`是待操作的表 `sep`是分隔符 一个字符串 这个函数会列出从`start`到`end`的所有元素 并用指定的分隔符隔开

`sep` `start` `end` 可以省略 省略情况下会从头部连接到尾部

```lua
local myTable = {11, 22, 33, 44, 55, 66}

print(table.concat(myTable)) --省略情况下
print(table.concat(myTable, ", ")) --指定其分隔符
print(table.concat(myTable, ", ", 2, 4)) --指定其首尾
```

---

<!-- _header: 8.6.2 插入 -->

## 插入

要在数组中插入一个元素可以使用`table.insert(table, pos, value)` `table`是要操作的那个表 `pos`是插入的点 `value`是插入的值 其中`pos`可省略 默认是在数组尾部插入

```lua
local myTable = {11, 22, 33, 44, 55, 66}
print(table.concat(myTable, ", ")) --输出表的预览

table.insert(myTable, 77) --不指定插入的位置 默认为尾部
print(table.concat(myTable, ", "))

table.insert(myTable, 5, 52) --指定插入的位置 会把后面的元素后移
print(table.concat(myTable, ", "))
```

---

<!-- _header: 8.6.3 删除 -->

## 删除

要从数组中删除元素 可以使用`table.remove(table, pos)` `table`是操作的表 `pos`是要删除的元素的索引 `pos`可以省略 默认从尾部删除

与插入不同 这个函数可以返回被删除的元素的值

```lua
local myTable = {11, 22, 33, 44, 55, 66}
print(table.concat(myTable, ", ")) --输出表的预览

local delete = table.remove(myTable) --删除尾部元素
print(table.concat(myTable, ", "))
print("被删除的元素是" .. delete)

delete = table.remove(myTable, 2) --删除指定元素 后面的元素会前移
print(table.concat(myTable, ", "))
print("被删除的元素是" .. delete)
```

---

<!-- _header: 8.6.4 排序 -->

## 排序

可以使用`table.sort(table, comp)`对一个数组排序 `table`操作的表 `comp`是一个排序规则函数 可省略

如果数组中的是字符串 根据其字母的排序 如果数组中的是数值 按数值升序排序(小的在前)

```lua
local tab = {13, 92, 4, 61, 71}
print(table.concat(tab, ", "))

table.sort(tab)

print(table.concat(tab, ", "))
```

---

<!-- _header: 8.6.4 排序 -->

### 根据数组元素的子字段排序

在某些情景中 数组中的元素是一个表 其中有一个特征值 我们需要根据那个表的特征值来进行排序 这样 就需要用到`table.sort`的`comp`参数了

例如 我们要做一个玩家排行榜 玩家数组中的每一个元素都有两个字段 `name`和`score` 分别代表其名字和分数 我们需要根据分数这一字段对玩家进行排序

这时 就需要在排序中这样操作

```lua
table.sort(table, function(a, b) return a.score < b.score end)
```

作者也不了解这个做法的基本原理 Lua官方文档中提到了这个用法 所以在这做演示

如果你用到这部分的内容 照着写就好了 如果你待排序的表的关键字段不是`score` 就把上面代码中的`score`改成你自己的字段即可

---

<!-- _header: 8.6.4 排序 -->

排行榜完整代码如下

```lua
local player = {
    {name = "杀手没有恨", score = 29},
    {name = "欧阳闻奕", score = 19},
    {name = "涟漪云帆", score = 20},
    {name = "忠鉴", score = 25}
}

table.sort(player, function(a, b) return a.score < b.score end)

--倒序遍历这个数组并输出玩家和分数(因为会升序排序)
for i = #player, 1, -1 do
    print(player[i].name, player[i].score)
end
```

---

<!-- _header: 8.7 关于表的元素为引用传递的说明 -->

# 关于表的元素为引用传递的说明

Lua中的表有一个特性: 所有的表都是引用传递的 这样说可能比较抽象 大家听不懂

这一节将给出一些说明

---

<!-- _header: 8.7 关于表的元素为引用传递的说明 -->

```lua
local tab1 = {11, 22, 33, 44, 55}
local tab2 = tab1 --这里把tab1指向的表赋值给tab2

--尝试索引和改变tab2中的值
print(tab2[2])
tab2[2] = 24
print(tab2[2])

--现在去检查tab1中的值 会发现其已经被改变了
print(tab1[2])
```

经过测试 我们发现 `tab2`的值被改变后 `tab1`中的值也会被改变 这说明它们两个变量背后是同一个表 而这些变量就是指向这个表的指针 任何的操作都会改变原始的表的内容

引用就是别名 比如 我的中文网名是`欧阳闻奕` 英文网名是`OWALabuy` 而这两个字段都能指我这个人 如果我长胖了 可以说"欧阳闻奕长胖了" 也可以说"OWALabuy长胖了"

---

<!-- _header: 9. 函数  -->

# 第九章 函数

---

<!-- _header: 9. 函数-目录  -->

> 1. 简介与构造方式
> 2. 参数与返回值
> 3. 操作
> 4. 变量的作用域
> 5. 匿名函数

---

<!-- _header: 10. 游戏数据抽象  -->

# 第十章 游戏数据抽象

---

<!-- _header: 10. 游戏数据抽象-目录  -->

> 1. API
> 2. 坐标系统
> 3. ID
> 4. UIN

---

<!-- _header: 11. 事件监听器  -->

# 第十一章 事件监听器

---

<!-- _header: 11. 事件监听器-目录  -->

> 简介
> 两种主流写法

---

<!-- _header: -->

<div class="columns">
<div>

</div>
<div>

</div>
</div>
